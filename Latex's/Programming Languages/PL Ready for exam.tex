\documentclass{article}
\usepackage[T2A]{fontenc}
\usepackage{fontspec}
\setmainfont{CMU Serif}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[russian]{babel}
\usepackage{xeCJK}% 调用 xeCJK 宏包
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{graphicx}
\setCJKmainfont{SimHei}

\begin{document}
\author{Сюй Минчуань}
\title{Подготовка к экзамену по языкам программированиям}
\maketitle
\section{Общие сведения о конечных автоматах. (Лекции по спецсеминару и практикуму, а также материал 2-го курса)}
	\textbf{(Недетерминированный) конечным автоматом} называется пятёрка
	\begin{equation}
	M=(Q,\Sigma, \delta, S, F)
	\end{equation}
	где\\
	$Q$ - конечное множество состояний\\
	$\Sigma$ - входный алфавит \\
	$\delta$ - функция переходов вида $Q\times(\Sigma \bigcup \{\varepsilon\}) \rightarrow \mathcal{P}(Q)$\\
	$S \subseteq Q$ - множество начальных состояний \\
	$F\subseteq Q$ - множество финальных состояний\\
	Функцию перехода также можно записывать в виде $\gamma: Q\times Q\rightarrow \mathcal{P}(\Sigma\bigcup\{\varepsilon\})$
	\\
	\textbf{Конфигурацией} КА называется $(q,a)$, где $q\in Q, a\in {\Sigma}^{*}$, $q$ - текущее состояние автомата, $a$ - нерассмотренная часть входной цепочки.  Или назовем множество $Q\times{\Sigma}^{*}$ \textbf{множеством конфигураций} автомата. На множестве конфигураций определим бинарное отношение $\Rightarrow$: $({q}_{1},u)\Rightarrow({q}_{2},v)$ тогда и только тогда, когда для некоторого $a\in \Sigma \bigcup \{\varepsilon\}$ выполнено условия $u=av$ и $\gamma({q}_{1},{q}_{2})\ni a$
	\\
	Конфигурации $(f,\varepsilon)$ для всех выходов $f\in F$ назовем \textbf{допускающими}. \\
	Для заданного слова $u$ назовем \textbf{стартовыми} конфигурации $(s,u)$ для всех входа $s\in S$.\\
	Множество допускаемых конечным автоматом слов есть \textbf{язык автомата}.\\
	
\section{Алгоритм детерминизации конечного автомата. (Лекции по спецсеминару и практикуму, а также материал 2-го курса)}
	Автомат является \textbf{детерминированным}, если для каждой пары $q\in Q, a\in \Sigma$ множество  содержало ровно 1 злемента.
	\emph{Процедура детерминизации конечного автомата}\\
	Пусть автомат задан следуюшим рисунком \ref{5}, запишем его в виде таблицы. Затем работать с множествами состояний и переобозначим их. В итоге получим детерминированный автомат.
	\begin{figure}[htbp] 
		\centering 
		\begin{minipage}[t]{0.48\textwidth} 
			\centering 
			\includegraphics[width=6cm]{5} 
			\caption{График автомата} 
			\label{5}
		\end{minipage} 
		\begin{minipage}[t]{0.48\textwidth} 
			\centering 
			\includegraphics[width=5cm]{6} 
			\caption{Автомат в виде таблицы} 
			\label{6}
		\end{minipage} 
	\end{figure}
	\begin{figure}[htbp] 
		\centering 
		\begin{minipage}[t]{0.48\textwidth} 
			\centering 
			\includegraphics[width=6cm]{7} 
			\caption{Обработка состояний} 
			\label{7}
		\end{minipage} 
		\begin{minipage}[t]{0.48\textwidth} 
			\centering 
			\includegraphics[width=5cm]{8} 
			\caption{Переобозначение множеств состояний} 
			\label{8}
		\end{minipage} 
	\end{figure}
	\begin{figure}[htbp] 
		\centering 
		\begin{minipage}[t]{0.48\textwidth} 
			\centering 
			\includegraphics[width=6cm]{9} 
			\caption{Новая таблица} 
			\label{9}
		\end{minipage} 
		\begin{minipage}[t]{0.48\textwidth} 
			\centering 
			\includegraphics[width=5cm]{10} 
			\caption{Новый график автомата} 
			\label{10}
		\end{minipage} 
	\end{figure}
 		
\section{Типы грамматик и соответствующие распознаватели. (Лекция 7-1)}
	Определение грамматики:
	\begin{equation}
	G=(V,T,P,S)
	\end{equation}
	где\\
	$V$ - конечный алфавит нетерминальных символов\\
	$T$ - конечный алфавит терминальных символов\\
	$P$ - конечное множество правил порождения\\
	$S\in V$ - начальный нетерминал грамматики $G$\\
	\textbf{Иерархия Хомского}\\
	0 - неограниченные грамматики (рекурсивно перечислимые) - Машина Тьюринга\\
	1 - $\forall \alpha \rightarrow \beta \in P, |\beta|\ge|\alpha|$ контекстно-зависимые грамматики - линейный ограниченный автомат(недетерномированная машина Тьюринга)\\
	2 - $\forall \alpha \rightarrow \beta \in P, |\beta|\ge|\alpha|.$ и верно $\alpha \in V$ контекстно-свободные грамматики - магазинный конечный автомат(автомат с магазинной памятью)\\
	3 - $\forall \alpha \rightarrow \beta \in P$ имеет вид: $A\rightarrow \omega, A\rightarrow \omega B$, где $A,B\in V,\omega \in {T}^{+}$регулярные грамматики - недетерминированный конечный автомат\\
	$S\rightarrow aSb\, |\, \varepsilon$ - простая скобочная грамматика - нерегулярный язык (далее это докажем)\\
	$S\rightarrow aSb\, |\, \varepsilon\,|\, SS$ - скобочная грамматика\\
	Автомат - это алгоритм, более формального сложного для восприятия компьютера\\
	Грамматика - это простая для восприятия человека\\
	\\
	
\section{Лемма о разрастании для регулярных языков и её применение. (Лекция 7-1)}
	\textbf{Лемма о разрастании для регулярных языков}
	Пусть $L$ - регулярный язык. Существует зависимое только от $L$ число $N$ такое, что для любого слова $|z|\ge N$ можно его разбить на части такие, что $z=uvw, |uv|\le N, |v|\ge1, u{v}^{i}w$ входят в язык для любого $i$ начиная с нуля и $N$ не больше чем минимальное число состояний ДКА, принимающей язык $L$. \\
		
	Использовать лемму докажем нерегулярность простой скобочной грамматикой. От противного: если регулярно, то верна лемма, то есть слово $aa..ab..bb$ можно разбить на $uvw$, причем $u{v}^{i}w$ тоже входит в язык, но такое v существует невозможно. Противоречие.\\
		
	Докажем лемму: Для любого регулярного языка существует эквивалентный детерномированный конечный автомат, в котором $n$ состояний. Возмем слово длины больше $n$, тогда есть одно состояние, через которое проходит дважды, пусть читается буква $v$, и для этой буквы делается цикл.
\section{Определение магазинного автомата на основе конечного автомата. (Лекция 7-2)}
	\textbf{Конечным автоматом} называется пятёрка
	\begin{equation}
	M=(Q,\Sigma, \delta, {q}_{0}, F)
	\end{equation}
	где\\
	$Q$ - конечное множество состояний\\
	$\Sigma$ - входный алфавит \\
	$\delta$ - функция переходов вида $Q\times(\Sigma \bigcup \{\varepsilon\}) \rightarrow \mathcal{P}(Q)$\\
	${q}_{0}\in Q$ - начальное состояние \\
	$F\subseteq Q$ - множество финальных состояний\\
	\\
	\textbf{Автоматом с магазинной памятью} называется семёрка
	\begin{equation}
    M=(Q,\Sigma, \Gamma, \delta, {q}_{0}, {z}_{0}, F)
	\end{equation}
	где\\
	$Q$ - конечное множество состояний\\
	$\Sigma$ - входный алфавит \\
	$\Gamma$ - алфавит магазина\\
	$\delta$ - функция переходов вида $Q\times(\Sigma \bigcup \{\varepsilon\})\times \Gamma \rightarrow \mathcal{P}(Q\times {\Gamma}^{*})$\\
	${q}_{0}\in Q$ - начальное состояние \\
	${z}_{0}\in \Gamma$ - вершина магазина\\
	$F\subseteq Q$ - множество финальных состояний\\

\section{Конфигурации магазинного автомата. Запись программы магазинного автомата в виде таблицы. (Лекции 7-2,8-1)}
	\textbf{Конфигурацией} КА называется $(q,a)$, где $q\in Q, a\in {\Sigma}^{*}$
	\\
	\textbf{Конфигурацией} магазиннго автомата называется $(q,a,z)$, где $q\in Q, a\in {\Sigma}^{*}, z\in {\Gamma}^{*}$\\
	Запись программы магазинного автомата в виде таблицы см. Таблицу 1.
	\begin{table}[!t]  \caption{программа магазинного автомата для скобочной грамматики $S\rightarrow aSb\, |\, \varepsilon\,|\, SS, \Gamma=\{{z}_{0},a\}$ в виде таблицы}
	\centering
		\begin{tabular}{cccc}  
			\toprule   
			$\Rightarrow$ & a &b & $\varepsilon$ \\  
			\midrule   
			$({q}_{0},{z}_{0})$ & $({q}_{0},{z}_{0}a)$ & ——— &$(f,\forall)$  \\  
			$({q}_{0},a)$ &  $({q}_{0},aa)$ &$({q}_{0},\varepsilon)$ &———  \\    
			\bottomrule  
		\end{tabular}
	\end{table}
\section{Магазинный автомат для скобочного языка. (Лекции 8-1,8-2)}
	Маршрут для \textbf{aabbab} : $aabbab\,|\,z\Rightarrow abbab\,|\,za\Rightarrow bbab\,|\,zaa\Rightarrow bab\,|\,za\Rightarrow ab\,|\,z\Rightarrow b\,|\,za\Rightarrow \varepsilon\,|\,z\Rightarrow f$\\
	Магазинный автомат для скобочного языка см. Таблицу 1.
\section{Соотношение любой–однозначный–детерминированный в случае языков (регулярных и КС) и автоматов. (Лекция 8-2)}
	детерминированный $\subset$ однозначный $\subset$ любой
\section{Магазинный автомат для простого скобочного языка. (Лекция 9-1)}
	Этот вопрос см. Таблицу 2
	\begin{table}[!t]  \caption{программа магазинного автомата для простой скобочной грамматики $S\rightarrow aSb\, |\, \varepsilon, \Gamma=\{{z}_{0},a\}$ в виде таблицы}
		\centering
		\begin{tabular}{cccc}  
			\toprule   
			$\Rightarrow$ & a &b & $\varepsilon$ \\  
			\midrule   
			$({q}_{0},{z}_{0})$ & $({q}_{0},{z}_{0}a)$ & ——— &$(f,\forall)$  \\  
			$({q}_{0},a)$ &  $({q}_{0},aa)$ &$({q}_{0},\varepsilon)$ &———  \\    
			$({q}_{1},a)$ & ——— & $({q}_{1},\varepsilon)$ & ———  \\  
			$({q}_{1},{z}_{0})$ & ——— & ——— &$(f,\forall)$  \\   
			\bottomrule  
		\end{tabular}
	\end{table}
\section{Магазинный автомат для недетерминированного языка. (Лекции 9-1,9-2)}
	Рассмотрим такую грамматику, строяшую так называемый \textbf{язык палиндромов}. Это язык чисто недетерминированный, каждое его слово содержит четное количество букв.\\
	$S\rightarrow aSa\, |\, bSb\,|\,\varepsilon, \Gamma=\{{z}_{0},a,b\}$\\
	Автомат см. Таблицу 3.
	
	\begin{table}[!t]\caption{программа магазинного автомата для языка палиндромов $S\rightarrow aSa\, |\, bSb\,|\,\varepsilon, \Gamma=\{{z}_{0},a,b\}$ в виде таблицы}
	\centering
		\begin{tabular}{cccc}
			\toprule
			\multicolumn{1}{c}{$\Rightarrow$} & \multicolumn{1}{c}{a} & \multicolumn{1}{c}{b} & \multicolumn{1}{c}{$\varepsilon$}   \\
			\midrule
			$({q}_{0},{z}_{0})$ & $({q}_{0},{z}_{0}a)$ & $({q}_{0},{z}_{0}b)$ & $(f,\forall)$    \\
			\multirow{2}{*}{$({q}_{0},a)$}   & $({q}_{0},aa)$  & \multirow{2}{*}{$({q}_{0},ab)$}   & \multirow{2}{*}{———}   \\
			& $({q}_{1},\varepsilon)$    &                       &                       \\
			\multirow{2}{*}{$({q}_{0},b)$}  & \multirow{2}{*}{$({q}_{0},ba)$}   & $({q}_{0},bb)$  & \multirow{2}{*}{———}   \\
			&                       & $({q}_{1},\varepsilon)$  &                        \\
			$({q}_{1},a)$  & $({q}_{1},\varepsilon)$   & ———  & ——— \\
			$({q}_{1},b)$  & ———  & $({q}_{1},\varepsilon)$  & ———  \\
			$({q}_{1},{z}_{0})$  & ———  & ———  & $(f,\forall)$           \\ 
			\bottomrule    
		\end{tabular}
	\end{table}
\section{Разбор сверху-вниз и автомат для него (не совсем верно, но отражает смысл — LL). (Лекции 9-3,10-1)}
	Это соответствует разделу 4.4.4 учебника "\emph{Компиляторы: принципы, технологии и инструментарии}" \\
	Здесь мы хотим построить автомат для произвольной контекстно-свободной грамматики, то есть придумываем метод, который автоматически создаёт магазинный автомат по заданной грамматике.\\
	$\Gamma=\{{z}_{0}\}\bigcup \Sigma \bigcup N$ где $\Sigma$ - множество терминалов, $N$ - множество нетерминалов.\\
	LL - читаем слево направа, и построим левый разбор. - \textbf{Нисходящий синтаксический анализ}\\
	$\delta':{\Sigma}_{\varepsilon}\times \Gamma \rightarrow \mathcal{P}({\Gamma}^{*})$.\\
	$\delta'(a,a)={\varepsilon}, \quad \forall a\in \Sigma$\\
	$\delta'(\varepsilon,A)\ni \alpha, \quad \forall A\rightarrow \alpha \in P$\\
	\emph{Пример}: Для грамматики
	\begin{equation}
	\begin{aligned}
	&E\rightarrow TE'\\
	&E'\rightarrow +TE'\,|\,\varepsilon\\
	&T\rightarrow FT'\\
	&T'\rightarrow *FT'\,|\,\varepsilon\\
	&F\rightarrow (E)\,|\,\text{id} 
	\end{aligned}
	\end{equation}
	выполнять нерекурсивный предктивный синтаксический анализ для строки \textbf{id}+\textbf{id}*\textbf{id}, который соответствует левому порождению
	\begin{equation}
	E\Rightarrow TE'\Rightarrow FT'E'\Rightarrow \text{id}E'\Rightarrow \text{id}+TE'\Rightarrow \ldots
	\end{equation}
	\begin{figure}
		\centering
		\includegraphics[width=0.7\linewidth]{4}
		\caption{Шаги, выполняемые придиктивным синтаксическим анализатором для входной строки \textbf{id}+\textbf{id}*\textbf{id}}
		\label{fig:4}
	\end{figure}
	\begin{figure}[htbp] 
	\centering 
		\begin{minipage}[t]{0.48\textwidth} 
		\centering 
		\includegraphics[width=5cm]{1} 
		\caption{Разбор сверху-вниз - LL} 
		\end{minipage} 
		\begin{minipage}[t]{0.48\textwidth} 
		\centering 
		\includegraphics[width=4cm]{2} 
		\caption{Разбор снизу-вверх - LR} 
		\end{minipage} 
	\end{figure}
\section{Разбор снизу-вверх и автомат для него (не совсем верно, но отражает смысл — LR). (Лекции 10-1,10-2)}
	Это соответствует разделу 4.5.3 учебника "\emph{Компиляторы: принципы, технологии и инструментарии}" \\
	$\Gamma=\{{z}_{0}\}\bigcup \Sigma \bigcup N$ где $\Sigma$ - множество терминалов, $N$ - множество нетерминалов.\\
	LR - читаем слево направа, и построим правый разбор. - \textbf{Восходящий синтаксический анализ}\\
	$\delta':{\Sigma}_{\varepsilon}\times {\Gamma}^{*} \rightarrow \mathcal{P}({\Gamma}^{*})$.\\
	\emph{Свёртка}: $\delta'(\varepsilon,\alpha)\ni A, \quad \forall A\rightarrow \alpha \in P$, то есть правая часть сворачиваемой строки должна распологаться на вершине стека. \\
	\emph{Перенос}: $\delta'(a,z\varepsilon)\ni za, \quad \forall a\in \Sigma, \forall z\in {\Gamma}^{*}$, то есть перенос очередного входного символа на вершину стека.\\
	\emph{Пример}: Для грамматики 
	\begin{equation}
	\begin{aligned}
	E\rightarrow E+T\,|\,T\\
	T\rightarrow T\times F\,|\,F\\
	F\rightarrow (E)\,|\,\text{id} 
	\end{aligned}
	\end{equation}
	выполнять синтаксический анализ для строки \textbf{id}1*\textbf{id}2
	\begin{figure}
		\centering
		\includegraphics[width=0.6\linewidth]{3}
		\caption{Пример применения алгоритма "переноса-свертки"}
		\label{fig:3}
	\end{figure}
\newpage
\section{Письменная часть экзамена}
Первый язык программирования высокого уровня, имеющий транслятор и испытавший дальнейшее развитие. Он значительно превзошел уровень языка ассемблера, стал Fortran который был разработан в 1950-х годах группой специалистов фирмы IBM во главе с Джоном Бекусом. 

Fortran встретил сильное противодействие по тем же причинам, что большинство программистов полагало, что сгенерированный компилятором программный код не может быть лучше написанного вручную на языке ассемблера, что является верной.

Подобно большинству первых языков программирования, Fortran имел серьёзные недостатки в деталях самого языка, и, что важнее, в нём отсутствовала поддержка современных концепций структурирования модулей и данных. Сам Бекус говорил: «Мы просто придумывали язык по мере его осмысления. Мы расценивали проектирование языка не как трудную задачу, а просто как прелюдию к реальной проблеме: проектированию компилятора, который мог бы генерировать эффективные программы». 

Однако преимущества абстракции быстро покорили большинство программистов: разработка программ стала более быстрой и надёжной, а их машинная зависимость уменьшилась из-за абстрагирования от регистров и машинных команд. Fortran стал стандартным языком в науке и технике, и только потом на смену ему приходят другие языки. Одно из преимуществ современного Фортрана — большое количество написанных на нём программ и библиотек подпрограмм.

Fortran был неоднократно модернизирован (1966, 1977, 1990) с тем, чтобы адаптировать его к требованиям современных программных разработок. Современный Фортран (Fortran 95 и Fortran 2003) приобрёл черты, необходимые для эффективного программирования, для новых вычислительных архитектур; позволяет применять современные технологии программирования, в частности, обобщённое и модульное программирование, ООП. Одна из главных концепций развития современного Фортрана — средства поддержки параллельности и векторные операции.

	
\end{document}


